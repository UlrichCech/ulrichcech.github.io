<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="UTF-8">
        <title>Ulrich's Developer Blog</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" href="../stylesheets/normalize.css" media="screen">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" media="screen">
        <link rel="stylesheet" type="text/css" href="../stylesheets/github-light.css" media="screen">

    </head>

    <body>
        <section class="page-header">
            <h1 class="project-name">Ulrich's Developer Blog</h1>
            <h2 class="project-tagline"></h2>
            <!--<a href="https://github.com/UlrichCech" class="btn">View on GitHub</a>-->
            <!--<a href="https://github.com/UlrichCech/javaee-mongo-morphia/zipball/master" class="btn">Download .zip</a>-->
            <!--<a href="https://github.com/UlrichCech/javaee-mongo-morphia/tarball/master" class="btn">Download .tar.gz</a>-->
        </section>

        <section style="float: right; min-width: 300px; margin-left:50px; margin-right: 50px; font-size: small;">
            <ul>
                <li><a href="../index.html">Home-Page</a></li>
                <li>2016</li>
                <ul>
                    <li>July</li>
                    <ul>
                        <li><a href="../articles/jmm-article-part1.html">JavaEE7 with MongoDB and Morphia (Part 1)</a></li>
                    </ul>
                </ul>
            </ul>
        </section>

        <section class="main-content">

            <h1><a href="#javaee-with-mongodb-and-morphia" id="javaee-with-mongodb-and-morphia" name="javaee-with-mongodb-and-morphia"><span class="octicon octicon-link"></span>JavaEE with MongoDB and Morphia</a></h1>
            <a href="https://github.com/UlrichCech/javaee-mongo-morphia/">View on GitHub</a>

            <h2><a href="#einleitung" id="einleitung" name="einleitung"><span class="octicon octicon-link"></span>Einleitung</a></h2>
            <p>MongoDB is an open-source, document database designed for ease of development and scaling. I don't want to recap all the
                key features of MongoDB here, must of the readers perhaps always know MongoDB, but for the one, who don't know anything
                about MongoDB, I suggest a shot introduction from the official MongoDB-documentation found here:<br />
                <a href="https://docs.mongodb.com/manual/introduction/">https://docs.mongodb.com/manual/introduction/</a></p>
            <p>There are already many articles and tutorials about the MongoDB-Java-Driver, but in this article, I want to step a bit
                further and show, how to basically design and implement a JavaEE Web-Application with MongoDB.
                For the persistence layer, we will use Morphia as an entity-mapper, which as very closely designed to the JPA-standard
                (you will be familiar with several annotation names).</p>
            <p>I don't want to show the typical &quot;Hello world&quot;-examples. I want to show you real-world scenarios, especially in case of
                the business objects. In addition, I want to build an architecture, that you can adopt 1-on-1 to real and productive
                business applications. For that, we want to implement a simple ordering-system which has users, products and orders.
                You will find the complete source code on my GitHub-account:<br />
                <a href="https://github.com/UlrichCech/javaee-mongo-morphia">https://github.com/UlrichCech/javaee-mongo-morphia</a> (use the GIT-Tag <strong><code>part_1</code></strong>)</p>
            <p>The only requirement is a current IDE with a configured JavaEE7-conform server (like Payara, Glassfish, Wildfly).
                I personally prefer Payara, because it is based on the reference implementation for JavaEE, namely Glassfish,
                and the Payara-team takes a lot of effort to extend it, update the libraries and make bugfixes with a quarterly
                update-cycle. If you look at the Github-repository of the Payara-team
                <a href="https://github.com/payara">https://github.com/payara</a>, you see plenty of commits (I think, they work 24 hours a day :-)).</p>
            <h2><a href="#motivation" id="motivation" name="motivation"><span class="octicon octicon-link"></span>Motivation</a></h2>
            <p>Especially with new projects you want to be productive quickly and achieve fast results. Traditionally in a
                JavaEE-environment, you will use JPA in the persistence layer, combined with a relational database.
                I will demonstrate how well MongoDB integrates into a JavaEE environment in conjunction with Morphia.
                It is intended to go especially to a certain 'elegance' and simplicity of the technologies.</p>
            <p>Typically, a SQL database server must be installed and configured, then you have to deal with the configuration of
                the Datasource and finally you must establish the connection via the persistence.xml in the application.</p>
            <p>In your traditional JavaEE-application design, you start to consider, how the business entities can be mapped to the
                individual tables and how their relationships are modeled.
                And exactly at this point, the problems get started, because a good domain driven design is very difficult to map
                to the relational model.
                Due to the distribution of data across a number of tables that are somewhat related (relational database model)
                we must always deal and think of transaction, because every update to the data involves always multiple tables,
                which must be updated in parallel. And there is a potential possibility, that another client wants to update a part
                of the same data at the same time.</p>
            <p>MongoDB goes one step further and does not offer transactions because transactions in most cases are actually not
                needed and are mainly needed in the 'relational world' because of the distribution of data across multiple tables.
                But in MongoDB we have a single &quot;document&quot; (perhaps with embedded sub-documents), which is considered as a complete
                unit and is persisted as this complete unit in one collection.
                So it cannot happen that an embedded sub-document (which would be stored in a relational model in another table),
                is used or updated by another process or user. There would be always the complete document, which is handled and
                updated as a unit and always the complete document will be saved or updated in the collection.
                So, the document itself is always consistent. This makes the developers' life much easier.
                Of course, different users can access or update one document as a whole in parallel, but the document will always be
                consistent and updated in a consistent way.
                If there is a conflict (because the current document is meanwhile updated by an other user), this situation can be
                identified via a special field of the entity, which is annotated with <code>@org.mongodb.morphia.annotations.Version</code>.
                It is the same behaviour as with JPA and provides a kind of optimistic locking.
                This conflict must be handled by the application, and the same is true for the relational model.
                But with the document centric approach, the possibility for a conflict is minimized and much easier to handle then in
                the old relational world.</p>
            <p>But sometimes, you really need the concept of a transaction. Then you can stick with the so called &quot;Two phase commit&quot;,
                which is described in very detail here:<br />
                <a href="https://docs.mongodb.com/manual/tutorial/perform-two-phase-commits/">https://docs.mongodb.com/manual/tutorial/perform-two-phase-commits/</a></p>
            <h2><a href="#domain-driven-design" id="domain-driven-design" name="domain-driven-design"><span class="octicon octicon-link"></span>Domain-Driven-Design</a></h2>
            <p>Basically the Domain Driven Design is understood to provide the business domain stand in the foreground.
                Until now, we always almost did quite some work with normalizing the database to reduce data duplication.</p>
            <p><strong>Example:</strong> A user has properties like a lastname, a firstname, age, username, password, birthdate. Mostly, the user
                has an address, too. And in a shop system, he needs a credit card or a bank account to make an order.
                If we use normalization, it will look like this:<br />
                User → Address<br />
                User → paymentMethod ← All-PaymentMethods</p>
            <p>Let's go one step further. In a shop system, every user has 0-n orders with 1-n articles/products:</p>
            <p>User → Order → orderedArticles ← articles</p>
            <p>Between orders and articles, we have a m:n-relation, one order can have multiple articles, and one article can be
                chosen in many orders. So in the relational model, we need 3 tables here.</p>
            <p>In a real shop-application, we cannot do this with a complete normalized database concept because if we only refer
                to the article, any change to the price of this article would be used for every reference. So if we want to know the
                total sum of a specific recent order, we will get different result with every change to a price of an article.
                We would always get the current price, not the price, when the user ordered this article.
                So, at this point, we have to break the normalization and store the price at the time of the order. Normally, we need
                to store the description as well to the order, so that in case of some complaint, we need to see the conditions for
                this article exactly to the time of the order. So we must store information redundantly for traceability and embed
                the articles to the order. When we embed these articles, the fields of the articles are 'copied' into the order table
                or into a corresponding table of 'ordered articles', when we model a 1:n-relation like this:<br />
                Order -&gt; OrderedArticles</p>
            <p>Another option could be to store only the changes, which are made at the article, as a kind of history, and if we need
                the state of the article to a special time, you have to reconstruct it with the information of the historical changes.
                But such history is not trivial to implement, especially with hierarchical structured entity.</p>
            <p>Ok, let's look at the implementation for the order process. We have to store information to several tables, which
                of course must be done in a transactional way in order to have a consistent state of our order.
                It makes no sense to store the main order information but without the ordered articles. So all tables have to be
                updates/inserted together.</p>
            <p>But, if we now look at the domain-model, it would know nothing of the various tables. It is one object with a list
                of ordered articles and the user, who has ordered these articles. This business object of such an order could be
                modelled as:</p>
            <pre><code class="java">class Order {
   private String orderNo;
   private Date orderDate;
   private User user;
   private List&lt;Article&gt; articles;

   public BigDecimal calculatePrice() {
       BigDecimal sum = BigDecimal.ZERO;
       for (Article article : articles) {
           sum.add(article.getBruttoPrice());
       }
   }
}
</code></pre>
            <pre><code class="java">class Article {
    private BigDecimal price;
    private double vat;

    public BigDecimal getBruttoPrice() {
        // TODO: calculate brutto;
    }
}
</code></pre>
            <p>This looks very similar to the JPA-structure, but we will see the the main difference or the advantage of MongoDB
                a bit later. In JPA, we would probably use <code>@ManyToOne</code> for the reference to the user, and an <code>@Embedded</code> für the
                list of articles.</p>
            <p>The attentive reader will have noticed, that there is a business method, namely the <code>calculatePrice()</code> method in the
                <code>Order</code> class. A classical JPA-object is usually an anaemic data container, a DTO with properties and only
                getter- and setter-methods.
                In a domain driven design, there are mostly rich-domain objects. 'Rich' in term of having additional business specific
                methods. In our example, the order knows best about its total price. So the method for calculating this total price
                would go into the `Order' class. You can image, what other methods could also go here, perhaps calculating taxes or
                something like this.</p>
            <p>In the typical and classical JPA-way, you would model the 'Order'-object the following way:</p>
            <pre><code class="java">@javax.persistence.Entity
class Order {
   private String orderNo;

   @Temporal(TemporalType.Date)
   private Date orderDate;

   @javax.persistence.Embedded
   private de.sofiworx.examples.jmm.business.user.entity.Address address;

   @OneToMany
   private List&lt;OrderedArtikel&gt; articles;

   // getter and setter
}
</code></pre>
            <p>Here we see the next big disadvantage of the relational database model:
                If we embed objects (in our case the address-object) and we change the address object (eg. add a new field), we always
                have to make a schema update. If we embed an <code>@Entity</code> we must update two tables, namely the table of the Entity and
                the table, where we embed this entity as well.
                MongoDB is schema-less, and that's a big advantage and give us a great performance hit through better productivity,
                because we do not have to make updates to the database, if we add some field to an object.</p>
            <p><strong>In summary:</strong> in the embedded scenario, where we want to add <em>one</em> more field to the embedded object, we need <em>two</em>
                schema updates to the relational database. Very un-productive, isn't it? in MongoDB, we do not need an update at all.
                Sure, it needs a bit of careful development here, because you don't want to deal with a hugh amount of different
                'object versions', which all will have different amount of property. This would be a nightmare in the application code
                to handle every version of our entities.
                But if you have this in mind, the schema-less paradigm is a hugh productivity goal.</p>
            <p>After this short introduction, we want to get started hacking.
                First, we will install our MongoDB, start the <strong>mongod</strong>-process (that's the MongoDB server deamon) and then we want
                to persist our first object into MongoDB.
                Let's go with hands-on-doing.</p>
            <h2><a href="#setup-a-mongodb-database-server" id="setup-a-mongodb-database-server" name="setup-a-mongodb-database-server"><span class="octicon octicon-link"></span>Setup a MongoDB database server</a></h2>
            <p>The first main advantage of MongoDB is its easy setup. There is no complicated installation process, just download
                the archive file, extract it and start the database-deamon:</p>
            <ol>
                <li>Download the newest MongoDB from
                    <a href="https://www.mongodb.org/downloads#production">https://www.mongodb.org/downloads#production</a></li>
                <li>use the archive file appropriate for your operating system</li>
                <li>Extract the file to directory, e.g. <code>/work/database/mongodb</code></li>
                <li>create the data directory <code>mkdir /work/database/mongodb/data</code></li>
                <li>on to the commandline type: <code>/work/database/mongodb/mongod -dbpath=data</code></li>
            </ol>
            <p>That's it. Now you have a MongoDB server running, on localhost with port 27017 (this is MongoDB-default).</p>
            <p>I will omit dealing with the Mongo-Client in Terminal window, create databases and collections and so on. Please refer
                to the official documentation of MongoDB and their tutorials for further information:<br />
                <a href="https://docs.mongodb.com/manual/">https://docs.mongodb.com/manual/</a></p>
            <p>Now, that we have the MongoDB-Server running, we want to connect to it from our application. So it is time to setup
                our application and start coding.</p>
            <p>We will start with a plain and clean Maven project, which can be used in every IDE of your choice. Start a new
                Maven-Project and use the following pom.xml:</p>
            <pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0
                             http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;de.sofiworx.examples&lt;/groupId&gt;
    &lt;artifactId&gt;javaee-mongo-morphia&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
        &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax&lt;/groupId&gt;
            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;
            &lt;version&gt;7.0&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;finalName&gt;javaee-mongo-morphia&lt;/finalName&gt;

        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/resources&lt;/directory&gt;
                &lt;excludes&gt;
                    &lt;exclude&gt;assemblies/**&lt;/exclude&gt;
                &lt;/excludes&gt;
                &lt;filtering&gt;true&lt;/filtering&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;

        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.1&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;source&gt;${maven.compiler.source}&lt;/source&gt;
                    &lt;target&gt;${maven.compiler.target}&lt;/target&gt;
                    &lt;compilerVersion&gt;${maven.compiler.source}&lt;/compilerVersion&gt;
                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.6&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
            <p>We only need dependency for JavaEE, for sure, and provide some basic plugins for compiling and building a WAR-file.</p>
            <p>For connecting to MongoDB and using Morphia as an object-mapper, we need two more dependencies.
                The first one is the dependency for the MongoDB-Java-Driver and the second one is Morphia:</p>
            <pre><code class="xml">...
&lt;dependency&gt;
    &lt;groupId&gt;org.mongodb&lt;/groupId&gt;
    &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt;
    &lt;version&gt;3.2.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mongodb.morphia&lt;/groupId&gt;
    &lt;artifactId&gt;morphia&lt;/artifactId&gt;
    &lt;version&gt;1.2.0&lt;/version&gt;
&lt;/dependency&gt;
...
</code></pre>
            <p>For the implementation, first we need a connection to our database. This connection is provided by the
                MongoDB-Java-Driver, which is comparable with the JDBC-driver.
                You can find more about the MongoDB Java Driver here:<br />
                <a href="https://github.com/mongodb/mongo-java-driver">https://github.com/mongodb/mongo-java-driver</a>
                But we neither use JPA nor some kind of Datasources and no persistence.xml, we implement our 'EntityManager'
                on our own:</p>
            <pre><code class="java">public class DBConnection {
    private static MongoClient mongo;

    public DBConnection() {
    }

    public void init() {
        if (mongo == null) {
            mongo = new MongoClient(&quot;localhost&quot;, 27017);
        }
    }

    public void closeConnection() {
        if (mongo != null) {
            mongo.close();
            mongo = null;
        }
    }
}
</code></pre>
            <p>If we instantiate the <code>DBConnection</code> class and call its <code>init()</code>-method, we see some log output like this:</p>
            <pre><code>INFORMATION: Monitor thread successfully connected to server with description ServerDescription{address=localhost:27017,
 type=STANDALONE, state=CONNECTED, ok=true, version=ServerVersion{versionList=[3, 2, 6]}, minWireVersion=0, maxWireVersion=4,
 maxDocumentSize=16777216, roundTripTimeNanos=1514197}
</code></pre>
            <p>=&gt; Now we have a client connection to our MongoDB database.</p>
            <p>Ok, we extend our example and want to persist our first object. For that, we use a simple and small JUnit-test case,
                where we implement the persisting of an object into the database:</p>
            <pre><code class="java">public class DBConnectionTest {

    @Test
    public void persistSimpleDocument() {
        DBConnection dbConnection = new DBConnection();
        dbConnection.init();
        final MongoClient mongoClient = dbConnection.getMongoClient();
        final MongoCollection&lt;Document&gt; testdataCollection =
                mongoClient.getDatabase(&quot;jmm&quot;).getCollection(&quot;testdata&quot;);
        try {
            Document storeDocument = new Document();
            storeDocument.put(&quot;field1&quot;, &quot;value1&quot;);
            storeDocument.put(&quot;field2&quot;, &quot;value2&quot;);
            storeDocument.put(&quot;field3&quot;, &quot;value3&quot;);
            testdataCollection.insertOne(storeDocument);
            assertThat(testdataCollection.count(), is(1L));
            final Document retrievedDocument =
                    mongoClient.getDatabase(&quot;jmm&quot;).getCollection(&quot;testdata&quot;)
                            .find().first();
            assertThat(retrievedDocument.containsKey(&quot;field2&quot;), is(true));
            System.out.println(retrievedDocument.toJson());
            testdataCollection.deleteOne(retrievedDocument);
            assertThat(testdataCollection.count(), is(0L));
        } finally {
             // completely clear the collection after test-execution
            testdataCollection.deleteMany(new BsonDocument());
        }
    }
}
</code></pre>
            <p>MongoDB has collections (which are somewhat comparable to the tables of a SQL database). Every entry in these
                collections is a document, and these documents consists of key-value-entries. A value can of course be again a
                document (then we name this a sub-documents), so we can model really complex and hierarchical objects,
                which are stored as one document into one collection.</p>
            <p>Ok, in this example, we put one document into the database and retrieved one document, so we can compare these two
                documents for equality. The document is finally printed out in JSON-format and should look like:</p>
            <pre><code class="json">{ &quot;_id&quot; : { &quot;$oid&quot; : &quot;57378c84ad595366d626540f&quot; },
  &quot;field1&quot; : &quot;value1&quot;,
  &quot;field2&quot; : &quot;value2&quot;,
  &quot;field3&quot; : &quot;value3&quot;
}
</code></pre>
            <p>For more examples of the MongoDB-JavaDriver, please refer to the following quick-tour:<br />
                <a href="http://mongodb.github.io/mongo-java-driver/3.0/driver/getting-started/quick-tour/">http://mongodb.github.io/mongo-java-driver/3.0/driver/getting-started/quick-tour/</a></p>
            <h2><a href="#morphia" id="morphia" name="morphia"><span class="octicon octicon-link"></span>Morphia</a></h2>
            <p>The MongoDB-Java driver provides us a good interface to the MongoDB database. The key-value-structure can easily
                be mapped to a simple Java-Map, so we have a really good known paradigm at hand to work with MongoDB.</p>
            <p>But, of course, we don't want to map every single property of our business objects on our own. We want to have some
                mapping tool or library, like an object-relational-mapper (ORM) in the JPA world. And here comes Morphia into play.</p>
            <p>Morphia is a MongoDB object-document mapper, developed in Java. It is based on the MongoDB-Java Driver and has the
                big advantage, that it is officially supported by MongoDB, because MongoDB developers support the Morphia
                codebase.</p>
            <ul>
                <li>You can find the website of Morphia here:<br />
                    <a href="https://mongodb.github.io/morphia/">https://mongodb.github.io/morphia/</a></li>
                <li>And the current latest documentation of Morphia is located at:<br />
                    <a href="http://mongodb.github.io/morphia/1.2/">http://mongodb.github.io/morphia/1.2/</a></li>
            </ul>
            <p><strong>Comment:</strong> Eclipselink and HibernateOGM provide some JPA-implementation for MongoDB. But in my opinion, these
                implementations are a bit away from real productive usage. It lacks mainly the multiple hierarchical structure, which
                MongoDB supports with the document-centric approach.</p>
            <p>Ok, now I want to show you, how you can map your first entity with Morphia:</p>
            <pre><code class="java">@org.mongodb.morphia.annotations.Entity(value = &quot;users&quot;, noClassnameStored = true)
public class User {

    @org.mongodb.morphia.annotations.Id
    private org.bson.types.ObjectId id;
    private String firstname;
    private String lastname;
    private Date birthdate;
    private String email;

    public User() {
    }


    public String getFullName() {
        return this.lastname + &quot;, &quot; + this.firstname;
    }

    // getter/setter/equals()/hashCode()
}
</code></pre>
            <p>You declare a persistent entity for Morphia with the <code>@Entity</code>-annotation, exactly the same like in JPA. The
                parameter 'value' points to the collection in MongoDB, where these entities should be stored. By default, Morphia
                stores the fully qualified classname in the 'classname'-field. This field is automatically added by Morphia and
                is used for mapping the MongoDB-document back to the Java-entity. This sounds reasonable, but the main drawback
                of this is, that refactorings in your code are not synchronized with the MongoDB-documents. So, if you move one
                entity to another package, Morphia is no longer able to map this entity correctly, because the stored classname
                does not longer match with your code.<br />
                Or, we always have to do some 'migration' and update the classname-field to the new one in every document of the
                collection in question. If this collection is very big, such updates are not possible in a production environment.
                So, we provide the annotation-parameter 'noClassnameStored' with a value of 'true', so that the classname is not
                stored along with the document. Morphia has to do some more work to find out the right class for the correct
                mapping, but now we are more flexible and need not take care, that the classname of the entities is always in
                sync with the implementation.</p>
            <p>Like each entity in JPA, every entity for Morphia and MongoDB needs a unique ID. MongoDB provides a very good concept
                of calculating a unique ID, namely an ObjectId (for more information on this topic, refer to<br />
                <a href="https://docs.mongodb.com/manual/reference/method/ObjectId/">https://docs.mongodb.com/manual/reference/method/ObjectId/</a>).<br />
                Morphia adopts this concept seamlessly. The only thing we have to do is to provide a property of type
                <code>org.bson.types.ObjectId</code> and annotate it with <code>@org.mongodb.morphia.annotations.Id</code>.
                Morphia will set this property transparently in background, when a new entity is persisted to MongoDB (we will see
                this later on) and fills it again transparently, when the entity is read back from MongoDB.</p>
            <p>In order to persist this entity to MongoDB via Morphia-mapping, we must initialize Morphia. So, we extend our
                <code>DBConnection</code> class as follows:</p>
            <pre><code class="java">public class DBConnection {
    private static MongoClient mongo;

    private static MongoClient mongo;
    private static Datastore datastore;


    public DBConnection() {
    }


    public void init() {
         if ((mongo == null) &amp;&amp; (datastore == null)) {
             mongo = new MongoClient(&quot;localhost&quot;, 27017);
             Morphia morphia = new Morphia();
             datastore = morphia.createDatastore(mongo, &quot;jmm&quot;);
         }
     }

     public Datastore getDatastore() {
         return datastore;
     }

}
</code></pre>
            <p>From now on, the <code>org.mongodb.morphia.Datastore</code> has the functionality of an EntityManager.
                We can use it, for example, in the following way (the easiest way again is to show it in a test case):</p>
            <pre><code class="java">@Test
public void persistEntityWithMorphia() {
    DBConnection dbConnection = new DBConnection();
    User testUser = new User();
    try {
        dbConnection.init();
        testUser.setFirstname(&quot;Max&quot;);
        testUser.setLastname(&quot;Mustermann&quot;);
        testUser.setBirthdate(new GregorianCalendar(1974, 10, 12, 0, 0).getTime());
        testUser.setEmail(&quot;max.mustermann@example.com&quot;);
        dbConnection.getDatastore().save(testUser);
        assertThat(testUser.getId(), notNullValue());
        final User retrievedUser =
                 dbConnection.getDatastore().find(User.class)
                         .filter(&quot;firstname&quot;, &quot;Max&quot;).get();
        assertThat(retrievedUser.getLastname(), is(&quot;Mustermann&quot;));
        assertThat(testUser.getId(), is(retrievedUser.getId()));
    } finally {
        dbConnection.getDatastore().delete(testUser);
    }
}
</code></pre>
            <p>Our <code>DBConncetion</code> is instantiated as before. Morphia is initialized as well, completely transparently.
                The Datastore is available for further use via the <code>DBConnection.getDatastore()</code> method.
                Then we create our business object and set some properties.<br />
                In the next step we pass this business entity to the <code>Datastore.save()</code> method, which takes care of it and
                persists our entity to the &quot;users&quot; collection in MongoDB.<br />
                I want to point to the assert-statement for 'not null' for the Id-property of the user after the save method.
                Here we see, that Morphia automatically stores the ObjectId, which was generated by MongoDB while saving the
                entity to the MongoDB-collection, to the <code>Id</code>-property of our entity.<br />
                In the next step, we query our just persisted entity again from MongoDB. Here, we use the <code>Datastore.find()</code> method,
                where we provide the class as search-parameter and tell Morphia with this class, that we search for objects
                of the typ of this class. With this information at hand, Morphia knows, in which collection to search
                (it get's this information from the 'value'-parameter of the <code>@Entity</code>-annotation).<br />
                In addition, we provide a filter. In our case, we want to find all users, which have a firstname of 'Max'. In this
                test, we know, that we will only get exactly one result, so that we can use the <code>Query.get()</code> method, which gives
                us exactly one User entity as the result.</p>
            <p><strong>Comment:</strong> If we replace <code>Query.get()</code> with <code>Query.iterator()</code>, we get an iterator, exactly an <code>Iterator&lt;User&gt;</code>,
                and with this iterator, we can loop over the resulting collection of users.</p>
            <p>Finally in our test case, we check, if we really have gotten the correct object from our query by comparing the unique
                ID properties.</p>
            <p>In a real business application, every entity has several properties, which are only technical. This could be
                a timestamp, when this entity was initially created or when this entity was last changed. And the property for the
                last change must be updated with every call to <code>Datastore.save()</code>. But we do not want to take care of these
                technical properties in our business methods.<br />
                Additionally, I bet, that you (and me of course, too) will forget to update such technical properties at some time.
                So, we want to handle these aspects somewhere in the background automatically as a &quot;cross-cutting-concern&quot;.
                For that, we define an abstract super-class, which all persistent entities have to extend:</p>
            <pre><code class="java">public abstract class PersistentEntity {

    @org.mongodb.morphia.annotations.Id
    private ObjectId id;

    @org.mongodb.morphia.annotations.Version
    private Long version;

    @org.mongodb.morphia.annotations.Property
    private Date created;

    @org.mongodb.morphia.annotations.Property
    private Date lastUpdate;

    @PrePersist
    protected void prePersist() {
        if (created == null) {
            created = new Date();
        }
        this.lastUpdate = new Date();
    }

    public ObjectId getId() {
        return id;
    }

    // getter/setter/equals()/hashCode()
}
</code></pre>
            <p>It is very important here to annotate our properties, which we want to have mapped in our entities, with
                <code>@org.mongodb.morphia.annotations.Property</code>.
                In a class, which is annotated with <code>@Entity</code>, all properties are mapped automatically by default. But in our
                abstract superclass, which is not annotated with <code>@Entity</code>, we must tell Morphia, which properties we want to
                have mapped from such an abstract superclass.<br />
                The attentive reader would have noticed, that I have added a field &quot;version&quot; which is annotated with <code>@Version</code>.
                This annotation works nearly the same as in JPA and takes care for an optimistic locking. When persisting the entity,
                Morphia looks first at the version field in the database, if it has the same value as in the object, which should
                currently be persisted. If it matches, everything is clear and the object is persisted. But if the value differs,
                Morphia knows, that some changes in between has occurred and rejects the persisting of this object.
                This field is automatically managed for you, you do not need to set a value here.</p>
            <p>For the property &quot;id&quot;, I only provide a getter-method. This should prevent our entity, that the &quot;id&quot; property
                is set or overridden by accident through application code.</p>
            <p>In the User-object, we can delete the <code>@Id</code>-property, because now we inherit from <code>PersistentEntity</code>.
                And after that we have the big advantage, that we only declare business properties in our business entities. All the
                technical aspects are in the background.</p>
            <pre><code class="java">@org.mongodb.morphia.annotations.Entity(value = &quot;users&quot;, noClassnameStored = true)
public class User extends PersistentEntity {

    private String firstname;
    private String lastname;
    private Date birthdate;
    private String email;

    ...
}
</code></pre>
            <p>If we now persist the entity with a call to <code>Datastore.save()</code>, the method with the annotaion <code>@PrePersist</code> is called
                first. In this method, we check, if we have a new entity or an existing/updated entity (in a new entity, the
                'created' property is null), and only in the case of a new entity, we set the 'created' property with the current
                timestamp.<br />
                The property 'lastUpdate' should be set or updated with the current timestamp in any situation.</p>
            <p>There are currently 5 lifecycle-methods, which are described here:
                <a href="https://github.com/mongodb/morphia/wiki/LifecycleMethods">https://github.com/mongodb/morphia/wiki/LifecycleMethods</a></p>
            <ul>
                <li>@PreLoad</li>
                <li>@PostLoad</li>
                <li>@PrePersist</li>
                <li>@PreSave</li>
                <li>@PostPersist</li>
            </ul>
            <p>We extend our last test-case with...</p>
            <pre><code class="java">...
dbConnection.getDatastore().save(testUser);
assertThat(testUser.getId(), notNullValue());
assertThat(testUser.getCreated(), notNullValue());
assertThat(testUser.getLastUpdate(), notNullValue());
...
</code></pre>
            <p>...and see, that it is green ;-). The two timestamps &quot;created&quot; and &quot;lastUpdate&quot; are set without setting them explicitly
                in our test case code.</p>
            <h2><a href="#javaee" id="javaee" name="javaee"><span class="octicon octicon-link"></span>JavaEE</a></h2>
            <h3><a href="#first-strike" id="first-strike" name="first-strike"><span class="octicon octicon-link"></span>First Strike</a></h3>
            <p>I hear you shout out loud: Where on earth is the JavaEE-part coming?
                Ok, let's integrated that with JavaEE. I assume, you have a JavaEE7-compatible server configured, so that we can deploy
                our application to it.</p>
            <p>First of all I want to show you the BCE-package structure. BCE stands for <em>B</em>oundary, <em>C</em>ontrol, <em>E</em>ntity. There
                is a nice short introduction video to this topic of Java Champion Adam Bien at<br />
                <a href="https://www.youtube.com/watch?v=grJC6RFiB58">https://www.youtube.com/watch?v=grJC6RFiB58</a>.</p>
            <p>This package-structure is perfect for Domain-Driven-Development, where every package-'container' (which consists of
                boundary, control and entity sub-package) is a part of the business domain.
                The 'boundary' and 'control' are both optional. In the boundary package, we put everything, which should be available
                to the outside-world for this business domain. For example, if we want to expose our list of users to an external
                system, we would provide a REST-service (eg. UsersResource), and this will go to the boundary package.</p>
            <p>Everything, which is used inside of our application, for example, the list of users, which should be displayed on a
                web-page of our application, is implemented in a controller, which goes to the controller-package.</p>
            <p>In our application, which we want to implement, there are 'users'. So we need an entity, namely the User-class, and
                some functionality around the user (adding, deletion and so on). So we structure our user-package like this:</p>
            <pre><code> de/sofiworx/examples/jmm/business/user/boundary
 de/sofiworx/examples/jmm/business/user/controller
   UserController.class
 de/sofiworx/examples/jmm/business/user/entity
   User.class
</code></pre>
            <p>The <code>User</code> class goes to the entity-package, our <code>UserController</code> goes to the controller-package.
                Boundary can be avoided, I list it here only for clarification.</p>
            <p>Ok, let's make our <code>DBConnection</code>-class a Singleton EJB. For that, we annotate the <code>DBConnection</code> class:</p>
            <pre><code class="java">@javax.ejb.Singleton
@javax.ejb.Startup
public class DBConnection {
...
}
</code></pre>
            <p>These two annotation make the EJB a singleton (<code>@Singleton</code>) and instantiate this class first when starting the
                application (<code>@Startup</code>).</p>
            <p>In addition, we annotate our <code>DBConnection.init()</code>-method with <code>@PostConstruct</code>, so that the database connection
                is initialized automatically when the <code>DBConnection</code> class is instantiated:</p>
            <pre><code class="java">@javax.annotation.PostConstruct
public void init() {
    ....
}
</code></pre>
            <p>Next, we annotate the <code>DBConnection.getDatastore()</code>-method with <code>@Produces</code>, so that we can inject the datastore in
                every managed bean (CDI, EJB).</p>
            <p><strong>Attention:</strong> It is important here to use &quot;RequestScoped&quot;, because the Morphia-Datastore is currently not
                Serializable and an injection into Session or ViewScoped-beans leads to a Weld-Error while starting the application,
                because of injecting a non-serializable bean into a serializable bean.</p>
            <pre><code class="java"> @javax.enterprise.inject.Produces
 @javax.enterprise.context.RequestScoped
 public Datastore getDatastore() {
     return datastore;
 }
</code></pre>
            <p>A simple example for using the injected datastore is the <code>UserController</code>:</p>
            <pre><code class="java">@javax.enterprise.context.SessionScoped
@javax.inject.Named
public class UserController implements Serializable {

    private static final long serialVersionUID = -6281169311696802773L;

    @Inject
    Datastore datastore;

    public long getCurrentAmountOfUsers() {
        return datastore.find(User.class).getCollection().getCount();
    }
}
</code></pre>
            <p>We further need the typical JavaEE-WebApp Artifacts like <code>beans.xml</code>, <code>web.xml</code> and <code>faces-config.xml</code>
                (because our frontend will be based on JSF), which we will put into the ``src/main/webapp/WEB-INF` folder.</p>
            <p><em>beans.xml</em></p>
            <pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee
                           http://xmlns.jcp.org/xml/ns/javaee/beans_1_1.xsd&quot;
       bean-discovery-mode=&quot;all&quot;&gt;
&lt;/beans&gt;
</code></pre>
            <p><em>web.xml:</em></p>
            <pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee
                             http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;javax.faces.PROJECT_STAGE&lt;/param-name&gt;
        &lt;param-value&gt;Development&lt;/param-value&gt;
    &lt;/context-param&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;javax.faces.INTERPRET_EMPTY_STRING_SUBMITTED_VALUES_AS_NULL&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/context-param&gt;


    &lt;servlet&gt;
        &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.xhtml&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;session-config&gt;
        &lt;session-timeout&gt;30&lt;/session-timeout&gt;
        &lt;tracking-mode&gt;COOKIE&lt;/tracking-mode&gt;
    &lt;/session-config&gt;

    &lt;welcome-file-list&gt;
        &lt;welcome-file&gt;index.xhtml&lt;/welcome-file&gt;
    &lt;/welcome-file-list&gt;

&lt;/web-app&gt;
</code></pre>
            <p><em>faces-config.xml:</em></p>
            <pre><code class="xml">&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;faces-config version=&quot;2.2&quot;
              xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
              xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
              xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee
                                  http://xmlns.jcp.org/xml/ns/javaee/web-facesconfig_2_2.xsd&quot;&gt;
    &lt;application&gt;
    &lt;/application&gt;
&lt;/faces-config&gt;
</code></pre>
            <p>Finally, we need the <code>index.xhtml</code> page, so that we can display our first message from our application:</p>
            <pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;
                      &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;
      xmlns:h=&quot;http://xmlns.jcp.org/jsf/html&quot;
      xmlns:f=&quot;http://xmlns.jcp.org/jsf/core&quot;&gt;

    &lt;f:view&gt;
        &lt;h:body&gt;
            &lt;h:outputText value=&quot;Hello from JavaEE with MongoDB. Currently, there are #{userController.getCurrentAmountOfUsers()} users in the database.&quot;/&gt;
        &lt;/h:body&gt;
    &lt;/f:view&gt;
&lt;/html&gt;
</code></pre>
            <p>We see, that we use the <code>UserController</code>-class from above, where the datastore is injected, so that we have direct
                access to our database-layer.</p>
            <p>If we deploy the application to our JavaEE7-server, start it and call the index-page in the browser, we should see
                something like this: <em>&quot;Hello from JavaEE with MongoDB. Currently, there are 0 users in the database.&quot;</em></p>
            <p>You see the simplicity in initialization of the persistence-layer. It is one class (<code>DBConnection</code>), and we only need
                to inject the <code>Datastore</code>, where ever we need the persistence-layer. And because of the document-centric approach,
                we need not care about transactions in the first place. The complete document is stored at once.
                This is very helpful in case of complex data structures, which we will see later on.</p>
            <p>If there is a conflict with concurrent access to the same entity, this is handled or better signalled by the
                <code>@Version</code> annotated field of our entities. If this situation occurs, a <code>java.util.ConcurrentModificationException</code>
                is thrown, which we need to handle according to the concrete business situation. It is not possible to handle this
                generically, because it depends really on the business use case.</p>
            <p>There are situations, where a so called &quot;Two-face-commit&quot; is needed, and there is a detailed article from MongoDB
                about this topic and how to implement this. Here is the link to the article:<br />
                <a href="https://docs.mongodb.com/v3.0/tutorial/perform-two-phase-commits/">https://docs.mongodb.com/v3.0/tutorial/perform-two-phase-commits/</a></p>
            <p>And, of course, even if we use a JavaEE-environment, our persistence-tests can be performed without the use of a
                testing framework like Arquillian. We can just use plain JUnit-tests for that. We don't need complicated
                persistence.xml for tests with a different database configuration, perhaps a different dialect-setup or something
                like that. We only need a test MongoDB instance, ideally locally started to run our persistence-tests against.</p>
            <p><strong>Comment:</strong> I will cover testing with MongoDB in a future article.</p>
            <p>OK, now we want to extend our application to setup a page for user-management, where we see a list of our users,
                and where we can add and remove users to our system. For that, we extend our <code>User</code>-class:</p>
            <pre><code class="java">@org.mongodb.morphia.annotations.Entity(value = &quot;users&quot;, noClassnameStored = true)
public class User {

    private String firstname;
    private String lastname;
    private Date birthdate;
    private String email;

    @org.mongodb.morphia.annotations.Embedded
    private Address address;

    ...
}
</code></pre>
            <pre><code class="java">@org.mongodb.morphia.annotations.Embedded
public class Address {

    private String street;
    private String streetNo;
    private String zipCode;
    private String city;

    public Address() {
    }

    // getter/setter/equals()/hashCode()
}

</code></pre>
            <p>Here, we define a so-called embeddable, which can be seen as sub-document. The MongoDB-document will later look like
                this, for example:</p>
            <pre><code class="json">{
    &quot;_id&quot; : ObjectId(&quot;12345678909876543456&quot;),
    &quot;firstname&quot; : &quot;Bruce&quot;,
    &quot;lastname&quot; : &quot;Wayne&quot;,
    &quot;birthdate&quot; : null,
    &quot;email&quot; : &quot;batman@gotham.org&quot;,
    &quot;address&quot; : {
        &quot;street&quot; : &quot;Main Street&quot;,
        &quot;streetNr&quot; : &quot;1&quot;,
        &quot;zipCode&quot; : &quot;12345&quot;,
        &quot;city&quot; : &quot;Gotham&quot;
    }
}
</code></pre>
            <p>Now, we extend the <code>UserController</code> for our JSF-page:</p>
            <pre><code class="java">@javax.enterprise.context.SessionScoped
@Named
public class UserController implements Serializable {

    private static final long serialVersionUID = -6281169311696802773L;

    private User userToAdd;

    private List&lt;User&gt; usersToShow;

    private String searchString;

    @Inject
    @RequestScoped
    private Datastore datastore;


    public UserController() {
    }

    @PostConstruct
    private void init() {
        showAllUsers();
    }

    public long getCurrentAmountOfUsers() {
        return datastore.find(User.class).getCollection().getCount();
    }

    private void showAllUsers() {
        usersToShow = datastore.createQuery(User.class).order(&quot;lastname,firstname&quot;).asList();
    }

    public void prepareNewUser() {
        userToAdd = new User();
    }

    public String addNewUser() {
        datastore.save(userToAdd);
        userToAdd = null;
        showAllUsers();
        return null;
    }

    public void removeUser(User userToDelete) {
        datastore.delete(userToDelete);
        showAllUsers();
    }

    public void searchUsers(String stringToSearch) {
        final Query&lt;User&gt; query = datastore.createQuery(User.class);
        if (stringToSearch != null) {
            query.or(query.criteria(&quot;firstname&quot;).contains(stringToSearch),
                     query.criteria(&quot;lastname&quot;).contains(stringToSearch));
        }
        usersToShow = query.asList();
    }

    @Produces
    @Named
    public User getUserToAdd() {
        return userToAdd;
    }

    public List&lt;User&gt; getUsersToShow() {
        return usersToShow;
    }

    public String getSearchString() {
        return searchString;
    }

    public void setSearchString(String searchString) {
        this.searchString = searchString;
    }
}
</code></pre>
            <p>Then, we extend the <code>index.xhtml</code>:</p>
            <pre><code class="xml">    &lt;f:view&gt;
        &lt;h:body&gt;
            &lt;div&gt;
                &lt;h:outputText value=&quot;Hello from JavaEE with MongoDB. Currently, there are #{userController.getCurrentAmountOfUsers()} user in the database.&quot;/&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;h:link value=&quot;User-Management&quot; outcome=&quot;users&quot; /&gt;
            &lt;/div&gt;
        &lt;/h:body&gt;
    &lt;/f:view&gt;
</code></pre>
            <p>And finally the <code>users.xhtml</code>:</p>
            <pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;
                      &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;
      xmlns:h=&quot;http://xmlns.jcp.org/jsf/html&quot;
      xmlns:f=&quot;http://xmlns.jcp.org/jsf/core&quot;&gt;

    &lt;f:view&gt;
        &lt;h1&gt;&lt;h:outputLabel value=&quot;Users&quot;/&gt;&lt;/h1&gt;

        &lt;h:panelGrid columns=&quot;2&quot;&gt;
            &lt;h:form&gt;
                &lt;h:inputText value=&quot;#{userController.searchString}&quot; /&gt;
                &lt;h:commandButton value=&quot;Search&quot;
                                 actionListener=&quot;#{userController.searchUsers(userController.searchString)}&quot;&gt;
                    &lt;f:ajax execute=&quot;@form&quot; render=&quot;userListForm&quot; /&gt;
                &lt;/h:commandButton&gt;
            &lt;/h:form&gt;
        &lt;/h:panelGrid&gt;

        &lt;h:form id=&quot;userListForm&quot;&gt;
            &lt;h:dataTable id=&quot;usersTable&quot; value=&quot;#{userController.usersToShow}&quot;
                         var=&quot;user&quot; style=&quot;border: 1px solid;&quot;&gt;
                &lt;h:column&gt;
                    &lt;f:facet name=&quot;header&quot;&gt;
                        Lastname
                    &lt;/f:facet&gt;
                    &lt;h:outputText value=&quot;#{user.lastname}&quot; /&gt;
                &lt;/h:column&gt;
                &lt;h:column&gt;
                    &lt;f:facet name=&quot;header&quot;&gt;
                        Firstname
                    &lt;/f:facet&gt;
                    &lt;h:outputText value=&quot;#{user.firstname}&quot; /&gt;
                &lt;/h:column&gt;
                &lt;h:column&gt;
                    &lt;f:facet name=&quot;header&quot;&gt;
                        eMail
                    &lt;/f:facet&gt;
                    &lt;h:outputText value=&quot;#{user.email}&quot; /&gt;
                &lt;/h:column&gt;
                &lt;h:column&gt;
                    &lt;f:facet name=&quot;header&quot;&gt;
                        Birthdate
                    &lt;/f:facet&gt;
                    &lt;h:outputText value=&quot;#{user.birthdate}&quot;&gt;
                        &lt;f:convertDateTime dateStyle=&quot;short&quot; locale=&quot;en-US&quot; /&gt;
                    &lt;/h:outputText&gt;
                &lt;/h:column&gt;
                &lt;h:column&gt;
                    &lt;h:commandButton value=&quot;Delete&quot;
                                     actionListener=&quot;#{userController.removeUser(user)}&quot; &gt;
                        &lt;f:ajax execute=&quot;@this&quot; render=&quot;usersTable&quot; /&gt;
                    &lt;/h:commandButton&gt;
                &lt;/h:column&gt;
            &lt;/h:dataTable&gt;
        &lt;/h:form&gt;

        &lt;h:panelGrid&gt;
            &lt;h:form&gt;
                &lt;h:commandButton value=&quot;New User&quot;
                                 actionListener=&quot;#{userController.prepareNewUser()}&quot;&gt;
                    &lt;f:ajax execute=&quot;@this&quot; render=&quot;newUserGrid&quot; /&gt;
                &lt;/h:commandButton&gt;
            &lt;/h:form&gt;
        &lt;/h:panelGrid&gt;
        &lt;h:panelGroup id=&quot;newUserGrid&quot; rendered=&quot;#{not (userToAdd eq null)}&quot;&gt;
            &lt;h:form id=&quot;newUserForm&quot;&gt;
                &lt;h:panelGrid columns=&quot;2&quot;&gt;
                    &lt;h:outputLabel value=&quot;Firstname&quot; /&gt;
                    &lt;h:inputText value=&quot;#{userToAdd.firstname}&quot; /&gt;
                    &lt;h:outputLabel value=&quot;Lastname&quot; /&gt;
                    &lt;h:inputText value=&quot;#{userToAdd.lastname}&quot; /&gt;
                    &lt;h:outputLabel value=&quot;eMail&quot; /&gt;
                    &lt;h:inputText value=&quot;#{userToAdd.email}&quot; /&gt;
                    &lt;h:outputLabel value=&quot;Birthdate&quot; /&gt;
                    &lt;h:inputText value=&quot;#{userToAdd.birthdate}&quot;&gt;
                        &lt;f:convertDateTime type=&quot;date&quot; pattern=&quot;MM.dd.yyyy&quot; locale=&quot;en-US&quot;/&gt;
                    &lt;/h:inputText&gt;
                    &lt;h:outputLabel value=&quot;Street&quot; /&gt;
                    &lt;h:inputText value=&quot;#{userToAdd.address.street}&quot; /&gt;
                    &lt;h:outputLabel value=&quot;Street No.&quot; /&gt;
                    &lt;h:inputText value=&quot;#{userToAdd.address.streetNo}&quot; /&gt;
                    &lt;h:outputLabel value=&quot;Zipcode&quot; /&gt;
                    &lt;h:inputText value=&quot;#{userToAdd.address.zipCode}&quot; /&gt;
                    &lt;h:outputLabel value=&quot;City&quot; /&gt;
                    &lt;h:inputText value=&quot;#{userToAdd.address.city}&quot; /&gt;
                    &lt;h:outputLabel value=&quot;&quot; /&gt;
                    &lt;h:commandButton value=&quot;Add&quot; action=&quot;#{userController.addNewUser}&quot; /&gt;
                &lt;/h:panelGrid&gt;
            &lt;/h:form&gt;
        &lt;/h:panelGroup&gt;
    &lt;/f:view&gt;

&lt;/html&gt;
</code></pre>
            <p>Now we have a first running example with quite some functionality like searching (with using the Morphia-query),
                adding new users and deleting existing users.
                Not really much code, isn't it?</p>
            <h3><a href="#extending-the-application-with-references-and-custom-type-converter" id="extending-the-application-with-references-and-custom-type-converter" name="extending-the-application-with-references-and-custom-type-converter"><span class="octicon octicon-link"></span>Extending the application with references and custom type-converter</a></h3>
            <p>In the next section, we will cover quite a lot of things at once.<br />
                First, we see, how to map references to other entities, as well as the mapping of a list of embedded objects.
                Second, we will look at, how we can enhance Morphia with a custom type-converter. This is useful, if we have some
                entity-types, which are not the basic ones like String or Numbers. For example, the <code>BigDecimal</code>, which is quite
                important to store prices, cannot be instantiated by Morphia because of the missing default constructor in
                <code>BigDecimal</code>. So we need a custom Morphia-converter to map BigDecimals back and forth.</p>
            <p>Ok, our application needs some articles or products which we can order. So, let's start with defining the product:
                we save the <code>Product</code>-class in <code>.../jmm/business/product/entity/Product.java</code></p>
            <pre><code class="java">@Entity(value = &quot;products&quot;, noClassnameStored = true)
public class Product extends PersistentEntity {

    private static final long serialVersionUID = -7245514305118509921L;

    private String productNo;

    private String description;

    private BigDecimal price;

    @org.mongodb.morphia.annotations.Transient
    private boolean selected;


    public Product() {
    }


    public String getSummary() {
        return this.productNo + &quot;, &quot; + this.getDescription() + &quot;, &quot; + this.getPrice().toString();
    }

    // getter/setter/equals()/hashCode()
</code></pre>
            <p>Everything cristal clear and not really new stuff, isn't it? There is only this <code>@Transient</code>-annotation. It is the
                same behaviour like in JPA, that this property is not mapped and persisted into the database. And if the
                entity is read from database, a transient property contains always the default value for the corresponding data type.</p>
            <p>For simplicity, we initialize the products programmatically, if they do not already exists. Therefore, we write a
                simple factory, which creates some products on startup <code>.../jmm/business/product/controller/ProductStartupFactory.java</code>:</p>
            <pre><code class="java">@Startup
@DependsOn(&quot;DBConnection&quot;)
@Singleton
public class ProductStartupFactory {

    @Inject
    Datastore datastore;

    @PostConstruct
    private void init() {
        if (datastore.find(Product.class).countAll() == 0) {
            for (int i = 1; i &lt; 12; i++) {
                Product product = new Product();
                product.setProductNo(Integer.toString(i));
                product.setDescription(&quot;Description of article with no. &quot; + i);
                product.setPrice(new BigDecimal(i));
                datastore.save(product);
            }
        }
    }
}
</code></pre>
            <p>Now, at every startup, the application looks, if there are products in the database and if not, some products are
                created, otherwise nothing is done.</p>
            <p>Before we can buy some products, we need to 'define' the current user. In a real application, this is done via
                login and then there is one current user in the session. In our case, we will simplify things a bit and select
                the current user from our users list via a button. Therefore, in <code>users.xhtml</code>, we extend our <code>h1</code>-tag with</p>
            <pre><code class="xml">&lt;h1&gt;
    &lt;h:outputText value=&quot;Users&quot;/&gt;
    &lt;h:panelGroup id=&quot;userLabel&quot; style=&quot;display: inline&quot; rendered=&quot;#{not (currentSelectedUser eq null)}&quot;&gt;
        &lt;h:outputText value=&quot; (#{currentSelectedUser.getFullName()})&quot; /&gt;
    &lt;/h:panelGroup&gt;
&lt;/h1&gt;
</code></pre>
            <p>In addition, we put a new column to our users-table so select one user as the current user of our order-session:</p>
            <pre><code class="xml">&lt;h:column&gt;
    &lt;f:facet name=&quot;header&quot;&gt;
        Select for orders
    &lt;/f:facet&gt;
    &lt;h:commandButton value=&quot;select&quot;
                     actionListener=&quot;#{userController.setCurrentSelectedUser(user)}&quot;&gt;
        &lt;f:ajax execute=&quot;@this&quot; render=&quot;userLabel&quot; /&gt;
    &lt;/h:commandButton&gt;
&lt;/h:column&gt;
</code></pre>
            <p>And finally, at the bottom of the users-page, we need a link to our order-page (which we will implement in a moment):</p>
            <pre><code class="xml">    ...
        &lt;h:panelGroup layout=&quot;block&quot; style=&quot;margin-top: 20px;&quot;
                      rendered=&quot;#{not (currentSelectedUser eq null)}&quot; &gt;
            &lt;h:link outcome=&quot;orders&quot; value=&quot;Goto orders&quot; /&gt;
        &lt;/h:panelGroup&gt;
    &lt;/f:view&gt;
&lt;/html&gt;
</code></pre>
            <p>Ok, that's all for the users-page. To make this 'compilable', we had to extend the <code>UserController</code>. First, we need a
                property for the current selected user and the corresponding get/set-methods:</p>
            <pre><code class="java">    private User currentSelectedUser;

    ...

    public void setCurrentSelectedUser(User currentSelectedUser) {
        this.currentSelectedUser = currentSelectedUser;
    }

    @Produces @de.sofiworx.examples.jmm.platform.cdi.Current
    @Named
    @javax.enterprise.context.Dependent
    public User getCurrentSelectedUser() {
        return currentSelectedUser;
    }
</code></pre>
            <p>The interesting part here are the annotations at the <code>getCurrentSelectedUser()</code> method. In order to inject and use the
                current selected user, we annotate it with <code>@Produces</code> and <code>@Named</code>, so we can use it in our JSF-page as well. But
                we have already a method, which produces a <code>User</code>-object (via the <code>getUserToAdd()</code>-method), so we have to add a
                qualifier annotation to distinguish between the both methods. The qualifier annotation is simply defined:</p>
            <pre><code class="java">@Qualifier
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER})
public @interface Current {}
</code></pre>
            <p>Now we can set the current user of our session via the button in the users-table. After selecting an user, the
                full name of this selected user is displayed at the top of the users-page and the link to the orders-page is
                displayed.</p>
            <p>Next, we need a controller for the products <code>.../jmm/business/product/controller/ProductController.java</code>:</p>
            <pre><code class="java">@ViewScoped
public class ProductController implements Serializable {

    private static final long serialVersionUID = -4166516355114826188L;

    @Inject
    Datastore datastore;

    @Produces
    @Named
    private List&lt;Product&gt; allAvailableProducts;


    public ProductController() {
    }


    @PostConstruct
    private void init() {
        allAvailableProducts = datastore.find(Product.class).asList();
    }

    public List&lt;Product&gt; getAllAvailableProducts() {
        return allAvailableProducts;
    }
}
</code></pre>
            <p>Finally, we will have a problem, when we persist a property with type <code>BigDecimal</code>. For example, if we store a
                <code>BigDecimal</code> with value &quot;4.01&quot;, this property is persisted in MongoDB as:</p>
            <pre><code class="json">&quot;bigDecimalValue&quot;: {
    &quot;scale&quot;: 2,
    &quot;precision&quot;: 3,
    &quot;intCompact&quot;: NumberLong(401)
  },
</code></pre>
            <p>But if we read such an entity withthis <code>BigDecimal</code> property via Morphia from MongoDB, we will get a RuntimeException:</p>
            <pre><code class="java">java.lang.RuntimeException: org.mongodb.morphia.mapping.MappingException:
   No usable constructor for java.math.BigDecimal
</code></pre>
            <p>Morphia cannot instantiate a <code>BigDecimal</code> and set the stored values back, because <code>BigDecimal</code> has no
                default constructor. But Morphia provides an easy way to overcome this situation with custom converters.
                There are only two methods, which you have to override, and we decide to use the String-representation of the
                <code>BigDecimal</code> for storing its value in Mongo. Such a custom converter can look like this:</p>
            <pre><code class="java">public class BigDecimalConverter extends org.mongodb.morphia.converters.TypeConverter
                                 implements org.mongodb.morphia.converters.SimpleValueConverter {

    public BigDecimalConverter() {
        super(BigDecimal.class);
    }

    @Override
    public Object encode(final Object value, final MappedField optionalExtraInfo) {
        if (value == null) {
            return null;
        }
        return value.toString();
    }

    @Override
    public Object decode(final Class targetClass, final Object fromDBObject,
                         final MappedField optionalExtraInfo) throws MappingException {
        if (fromDBObject == null) {
            return null;
        }
        return new BigDecimal(fromDBObject.toString());
    }
}
</code></pre>
            <p>Of course, the custom converters must be registered for Morphia. We do this in our <code>DBConnection.init()</code>-method:</p>
            <pre><code class="java">morphia.getMapper().getConverters().addConverter(BigDecimalConverter.class);
</code></pre>
            <h3><a href="#order-page" id="order-page" name="order-page"><span class="octicon octicon-link"></span>Order-page</a></h3>
            <p>In order to make our link to the order page work, we have to implement the <code>orders.xhtml</code>-page.
                On this page, we want to display the recent orders of the current user. Furthermore, we display all available products
                in a table, which can be selected via checkbox. And of course, we need a button to submit the order, so the user
                can order his selected products.
                After an order is submitted, the order is displayed in the top table for the current user.</p>
            <pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;
                      &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;
      xmlns:h=&quot;http://xmlns.jcp.org/jsf/html&quot;
      xmlns:f=&quot;http://xmlns.jcp.org/jsf/core&quot;
      xmlns:ui=&quot;http://xmlns.jcp.org/jsf/facelets&quot;&gt;

    &lt;f:view&gt;
        &lt;h1&gt;
            &lt;h:outputText value=&quot;Orders&quot;/&gt;
            &lt;h:panelGroup id=&quot;userLabel&quot; style=&quot;display: inline&quot;
                          rendered=&quot;#{not (currentSelectedUser eq null)}&quot;&gt;
                &lt;h:outputText value=&quot; (#{currentSelectedUser.getFullName()})&quot; /&gt;
            &lt;/h:panelGroup&gt;
        &lt;/h1&gt;

        &lt;h:panelGroup layout=&quot;block&quot; style=&quot;margin-top: 20px;&quot;&gt;
            &lt;h:dataTable value=&quot;#{allOrdersOfCurrentUser}&quot; var=&quot;order&quot;
                         style=&quot;border: 1px solid;&quot;&gt;
                &lt;h:column&gt;
                    &lt;f:facet name=&quot;header&quot;&gt;
                        Order date
                    &lt;/f:facet&gt;
                    &lt;h:outputText value=&quot;#{order.orderDate}&quot; /&gt;
                &lt;/h:column&gt;
                &lt;h:column&gt;
                    &lt;f:facet name=&quot;header&quot;&gt;
                        Total amount
                    &lt;/f:facet&gt;
                    &lt;h:outputText value=&quot;#{order.totalAmount}&quot; /&gt;
                &lt;/h:column&gt;
                &lt;h:column&gt;
                    &lt;f:facet name=&quot;header&quot;&gt;
                        Ordered products
                    &lt;/f:facet&gt;
                    &lt;h:panelGroup&gt;
                        &lt;ul&gt;
                            &lt;ui:repeat value=&quot;#{order.orderedProducts}&quot; var=&quot;product&quot;&gt;
                            &lt;li&gt;
                                &lt;h:outputText value=&quot;#{product.getSummary()}&quot; /&gt;
                            &lt;/li&gt;
                            &lt;/ui:repeat&gt;
                        &lt;/ul&gt;
                    &lt;/h:panelGroup&gt;
                &lt;/h:column&gt;
            &lt;/h:dataTable&gt;
        &lt;/h:panelGroup&gt;

        &lt;h:panelGroup layout=&quot;block&quot; style=&quot;margin-top: 20px;&quot;&gt;
            &lt;h:form&gt;
                &lt;h:dataTable value=&quot;#{allAvailableProducts}&quot; var=&quot;product&quot;
                             style=&quot;border: 1px solid;&quot;&gt;
                    &lt;h:column&gt;
                        &lt;f:facet name=&quot;header&quot;&gt;
                            Product No.
                        &lt;/f:facet&gt;
                        &lt;h:outputText value=&quot;#{product.productNo}&quot; /&gt;
                    &lt;/h:column&gt;
                    &lt;h:column&gt;
                        &lt;f:facet name=&quot;header&quot;&gt;
                            Description
                        &lt;/f:facet&gt;
                        &lt;h:outputText value=&quot;#{product.description}&quot; /&gt;
                    &lt;/h:column&gt;
                    &lt;h:column&gt;
                        &lt;f:facet name=&quot;header&quot;&gt;
                            Price
                        &lt;/f:facet&gt;
                        &lt;h:outputText value=&quot;#{product.price}&quot; &gt;
                            &lt;f:convertNumber maxFractionDigits=&quot;2&quot; minFractionDigits=&quot;2&quot;
                                             locale=&quot;en-US&quot; /&gt;
                        &lt;/h:outputText&gt;
                    &lt;/h:column&gt;
                    &lt;h:column&gt;
                        &lt;h:selectBooleanCheckbox value=&quot;#{product.selected}&quot; /&gt;
                    &lt;/h:column&gt;
                &lt;/h:dataTable&gt;
                &lt;h:commandButton value=&quot;Submit order&quot;
                                 action=&quot;#{orderController.placeOrder}&quot;&gt;
                    &lt;f:ajax render=&quot;@all&quot; execute=&quot;@form&quot; /&gt;
                &lt;/h:commandButton&gt;
            &lt;/h:form&gt;
        &lt;/h:panelGroup&gt;

        &lt;h:panelGroup layout=&quot;block&quot; style=&quot;margin-top: 20px;&quot;&gt;
            &lt;h:link value=&quot;Back to users&quot; outcome=&quot;users&quot; /&gt;
        &lt;/h:panelGroup&gt;
    &lt;/f:view&gt;
&lt;/html&gt;
</code></pre>
            <p>Ok, the page was easy, now we need to implement the business logic. First, we start with the <code>Order</code>-class, which
                we store in:<br />
                <code>de/sofiworx/examples/jmm/business/order/entity/Order.java</code></p>
            <pre><code class="java">@Entity(value = &quot;orders&quot;, noClassnameStored = true)
public class Order extends PersistentEntity {

    private static final long serialVersionUID = 7958903679851324189L;

    private Date orderDate;

    private BigDecimal totalAmount;

    @org.mongodb.morphia.annotations.Reference
    private User user;

    @org.mongodb.morphia.annotations.Embedded
    private List&lt;Product&gt; orderedProducts;

    // getter/setter/equals()/hashCode()
}
</code></pre>
            <p>Our <code>Order</code>-object would be very simple and only contains the date of the order, the total amount of all ordered
                products, the reference to the user, who placed the order and of course the list of the products. It is important
                here, that we don't store only references to the products but the products as a whole. This is important for the
                business case, that we need the prices and the state of the products to the time, when they are ordered.
                If someone changes the price in the central product-collection, this changes does not affect already placed orders.</p>
            <p>Next, we need the <code>OrderController</code>, which we store in<br />
                <code>de/sofiworx/examples/jmm/business/order/controller/OrderController.java</code>:</p>
            <pre><code class="java">@ViewScoped
@Named
public class OrderController implements Serializable {

    private static final long serialVersionUID = 3341943397531831252L;

    @Inject
    Datastore datastore;

    @Inject @Current
    User currentSelectedUser;

    @Inject
    ProductController productController;

    private List&lt;Order&gt; allOrdersOfCurrentUser;


    public OrderController() {
    }


    @PostConstruct
    private void init() {
        final Query&lt;Order&gt; query = datastore.createQuery(Order.class);
        query.criteria(&quot;user&quot;).equal(currentSelectedUser);
        allOrdersOfCurrentUser = query.asList();
        productController.getAllAvailableProducts().stream()
                .forEach(p -&gt; p.setSelected(false));
    }


    @Produces
    @Named
    public List&lt;Order&gt; getAllOrdersOfCurrentUser() {
        return allOrdersOfCurrentUser;
    }

    public void placeOrder() {
        final List&lt;Product&gt; selectedProducts =
                productController.getAllAvailableProducts().stream()
                        .filter(Product::isSelected)
                        .collect(Collectors.toList());
        Order order = new Order();
        order.setOrderDate(new Date());
        order.setUser(currentSelectedUser);
        order.setOrderedProducts(selectedProducts);
        Function&lt;Product, BigDecimal&gt; totalMapper = Product::getPrice;
        BigDecimal total = selectedProducts.stream()
                .map(totalMapper).reduce(BigDecimal.ZERO, BigDecimal::add);
        order.setTotalAmount(total);
        datastore.save(order);
        init();
    }

}
</code></pre>
            <p>And last but not least, we need the <code>ProductController</code>, which provides access to our products-list. We store it in<br />
                <code>de/sofiworx/examples/jmm/business/product/controller/ProductController.java</code>:</p>
            <pre><code class="java">@ViewScoped
public class ProductController implements Serializable {

    private static final long serialVersionUID = -4166516355114826188L;

    @Inject
    Datastore datastore;

    @Produces
    @Named
    private List&lt;Product&gt; allAvailableProducts;


    public ProductController() {
    }


    @PostConstruct
    private void init() {
        allAvailableProducts = datastore.find(Product.class).asList();
    }

    public List&lt;Product&gt; getAllAvailableProducts() {
        return allAvailableProducts;
    }
}
</code></pre>
            <p>And that's it. You see, MongoDB, JavaEE and Morphia fit together perfectly. With minimal code, we have implemented
                quite some functionality in our Web-application. And we have only touched the surface. MongoDBs big advantage,
                that it is schema-less, comes into play, if you change/extend your business objects. You don't have to update the
                database, just add the property to your business object and nothing more.</p>
            <p>I hope, you find this article somewhat helpful and I appreciate every kind of feedback on this. You can reach me
                on <em>developer(at)cech-home.de</em></p>



            <footer class="site-footer">
                <span class="site-footer-owner"><a href="https://ulrichcech.github.io">Ulrich's Developer Blog</a> is maintained by <a
                        href="https://github.com/UlrichCech">UlrichCech</a>.</span>

                <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a
                        href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a
                        href="https://twitter.com/jasonlong">Jason Long</a>.</span>
            </footer>

        </section>


    </body>
</html>
